////   什么是多态？   父类指针指向一个子类的对象，通过父类的指针调用这个实际的子类的成员函数，
////                  使父类的指针有多种形态
////   多态基于什么实现的？   多态基于虚函数实现的，虚基于重写
////   多态实现的原理？      1.维护一个虚函数列表v_table，还有一个虚指针vfptr,
////                          2.虚函数列表v_table是在编译期存在，每个类只有一份，所有对象共享的
////                          3.虚指针vfptr是在创建对象的时候存在，是父类中的一个成员，
////						    在构造函数里初始化指向自己类虚函数列表
////                          4.如果调用的函数是一个虚函数，就要通过vfptr找到列表中的函数调用，
////                            在子类中重写了把父类的虚函数覆盖，调用的实际上是子类
////   多态的优缺点？         优点： 复用和扩展。  缺点：空间，效率
//
////   调用哪个类的函数？
////   看  调用的函数在当前这个指针的类中是不是虚函数。 
////       是虚函数，调用当前的虚函数列表中的函数 （和指针的类型是没有关系的）  即你new类是哪个类
////       不是虚函数，指针是什么类型的就调用哪个类的 （和对象没有关系了）
//
//
//#include <iostream>
//using namespace std;
//
//class CFather
//{
//public:
//	CFather()
//	{
//		cout << "CFather" << endl;
//	}
//	virtual ~CFather()    //  虚析构   通过父类的指针删除一个子类的对象，防止内存泄露
//	{
//		cout << "~CFather" << endl;
//	}
//};
//
//class CSon : public CFather
//{
//public:
//	CSon()
//	{
//		cout << "CSon" << endl;
//	}
//	~CSon()
//	{
//		cout << "~CSon" << endl;
//	}
//};
//
//int main()
//{
//
//	{
//		CFather* p = new CSon;//如果不是虚析构 父类就不会析构 只会 CFather    CFather
                                                                                                                                  CSon        CSon
//		delete p;                                                                                    ~Con        ~Con
//		p = 0;                                                                                                         ~CFather  （虚析构）  
//	}
//
//	system("pause");
//	return 0;
//}
//
